from __future__ import with_statement
import sqlite3, os, shutil, subprocess, hashlib, re
from flask import Flask, request, g, redirect, url_for, \
     abort, render_template, flash
from werkzeug.utils import secure_filename
from flask import send_from_directory
from contextlib import closing


#configure
DATABASE = 'malDetect.db'
DEBUG = True
SECRET_KEY = 'development key'
USERNAME = 'admin'
PASSWORD = 'zwbxinan'
UPLOAD_FOLDER = 'apk_upload'
TMP_FOLDER = 'tmp'
ALLOWED_EXTENSIONS = set(['apk'])

app = Flask(__name__)
app.config.from_object(__name__)
app.config.from_envvar('MALDETECT_SETTINGS', silent = True)

P = None

def connect_db():
    return sqlite3.connect(app.config['DATABASE'])

def init_db():
    with closing(connect_db()) as db:
        with app.open_resource('schema.sql') as f:
            db.cursor().executescript(f.read())
        db.commit()

def delect_table():
    g.db.execute("DROP TABLE IF EXISTS entries;")
    g.db.commit()

@app.before_request
def before_request():
    g.db = connect_db()

@app.teardown_request
def teardown_request(exception):
    g.db.close()


# @app.route('/')
# def show_entries():
#     cur = g.db.execute('select title, text from entries order by id desc')
#     entries = [dict(title=row[0], text=row[0]) for row in cur.fetchall()]
#     return render_template('show_entries.html', entries=entries)

@app.route('/')
def index():
    #delect_table()

    return render_template('index.html')


# def add_entry(sha1):
#     #g.db.execute('insert into entries (title, text) values (?, ?)', [request.form['title'], request.form['text']])
#     g.db.execute('insert into entries (filename, sha1, filesize) values (?, ?, ?)', ['jimm-1', sha1, '1.2'])
#     g.db.commit()

def allowed_file(filename):
    return '.' in filename and \
           filename.rsplit('.', 1)[1] in ALLOWED_EXTENSIONS

@app.route('/', methods = ['POST', 'GET'])
def upload_file():
    #success = 'False'
    sha1 = None
    if request.method == 'POST':
        file = request.files['file']
        if file and allowed_file(file.filename):
            file_name = secure_filename(file.filename)

            try:
                file.save(os.path.join(app.config['TMP_FOLDER'], file_name))
                #success = 'True'
                fp = open(app.config['TMP_FOLDER'] + '/' + file_name,'rb')
                fdata = fp.read()
                fp.close()
                sha1obj = hashlib.sha1()
                sha1obj.update(fdata)
                sha1 = sha1obj.hexdigest()
                new_name = file_name.split('.')[0]+'_'+sha1+'.'+file_name.split('.')[-1]
                os.rename(os.path.join(app.config['TMP_FOLDER'], file_name), os.path.join(app.config['TMP_FOLDER'], new_name))
                shutil.move(os.path.join(app.config['TMP_FOLDER'], new_name),os.path.join(app.config['UPLOAD_FOLDER'], new_name))

                return redirect(url_for('upload_success', filename=file_name, sha1=sha1))
            except:
                pass
        return redirect(url_for('upload_failed'))


    return render_template('index.html')

@app.route('/search', methods=['POST', 'GET'])
def search():
    if request.method == 'POST':
        sha1 = str(request.form['text'])
        pattern = re.compile(r'[a-z0-9]{40}')
        match = pattern.match(sha1)
        if not match:
            return render_template('search_failed.html', regFail=True)
        cur = g.db.execute("select * from entries where sha1='%s'" %sha1)
        res = cur.fetchall()
        if len(res) != 0:
            row = res[0]
            entry = dict(filename='*', sha1=row[2], filesize=row[3], prob=row[4], permission=row[5], APIs=row[6])
            return render_template('report.html', finished=True, entry=entry)
        else:
            return render_template('search_failed.html')

@app.route('/upload_success/<filename>/<sha1>')
def upload_success(filename, sha1):
    global P
    P = subprocess.Popen('python process.py ' + filename + " " + sha1, shell=True, stdout=subprocess.PIPE)
    return render_template('upload_success.html', P = P)

@app.route('/upload_failed')
def upload_failed():
    return render_template('upload_failed.html')


@app.route('/report')
def report():
    global P
    if(P != None):
        if P.poll() == None:
            return render_template('report.html', finished=False)
        else:
            stdout = P.communicate()[0].split()
            entry = dict(filename=stdout[0], sha1=stdout[1], filesize=stdout[2], prob=stdout[3], permission=stdout[4], APIs=stdout[5])
            return render_template('report.html', finished=True, entry=entry)


if __name__ == "__main__":
    init_db()
    app.run(debug = True, host='0.0.0.0')